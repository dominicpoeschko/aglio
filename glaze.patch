diff --git a/include/glaze/core/write.hpp b/include/glaze/core/write.hpp
index e5bb16b3..c6994341 100644
--- a/include/glaze/core/write.hpp
+++ b/include/glaze/core/write.hpp
@@ -94,33 +94,33 @@ namespace glz
    }
 
    template <auto Opts, class T, raw_buffer Buffer>
       requires write_supported<T, Opts.format>
    [[nodiscard]] error_ctx write(T&& value, Buffer&& buffer, is_context auto&& ctx)
    {
       size_t ix = 0;
       to<Opts.format, std::remove_cvref_t<T>>::template op<Opts>(std::forward<T>(value), ctx, buffer, ix);
       if (bool(ctx.error)) [[unlikely]] {
          return {ix, ctx.error, ctx.custom_error_message};
       }
       return {ix, error_code::none, ctx.custom_error_message};
    }
 
    template <auto Opts, class T, raw_buffer Buffer>
       requires write_supported<T, Opts.format>
    [[nodiscard]] error_ctx write(T&& value, Buffer&& buffer)
    {
       context ctx{};
       return write<Opts>(std::forward<T>(value), std::forward<Buffer>(buffer), ctx);
    }
 
    // requires file_name to be null terminated
    [[nodiscard]] inline error_code buffer_to_file(auto&& buffer, const sv file_name)
    {
-      auto file = std::ofstream(file_name.data(), std::ios::out);
-      if (!file) {
-         return error_code::file_open_failure;
-      }
-      file.write(buffer.data(), buffer.size());
+      //auto file = std::ofstream(file_name.data(), std::ios::out);
+      //if (!file) {
+      //   return error_code::file_open_failure;
+      //}
+      //file.write(buffer.data(), buffer.size());
       return {};
    }
 }
diff --git a/include/glaze/file/file_ops.hpp b/include/glaze/file/file_ops.hpp
index c3376e83..4bb8b1dc 100644
--- a/include/glaze/file/file_ops.hpp
+++ b/include/glaze/file/file_ops.hpp
@@ -2,75 +2,75 @@
 // For the license information refer to glaze.hpp
 
 #pragma once
 
 #include <cstdio>
 #include <filesystem>
 #include <string>
 
 #include "glaze/core/context.hpp"
 
 #if defined(_MSC_VER) && !defined(__clang__)
 // Turn off MSVC warning for unsafe fopen
 #pragma warning(push)
 #pragma warning(disable : 4996)
 #endif
 
 namespace glz
 {
    template <class T>
    [[nodiscard]] error_code file_to_buffer(T& buffer, auto* file, const std::string_view path)
    {
       if (!file) {
          return error_code::file_open_failure;
       }
 
-      std::error_code ec{};
-      const auto n = std::filesystem::file_size(path, ec);
-      if (ec) {
-         std::fclose(file);
-         return error_code::file_open_failure;
-      }
-      buffer.resize(n);
+      //std::error_code ec{};
+      //const auto n = std::filesystem::file_size(path, ec);
+      //if (ec) {
+      //   std::fclose(file);
+      //   return error_code::file_open_failure;
+      //}
+      //buffer.resize(n);
 
-      if (n != std::fread(static_cast<void*>(buffer.data()), 1, n, file)) {
-         std::fclose(file);
-         return error_code::file_open_failure;
-      }
+      //if (n != std::fread(static_cast<void*>(buffer.data()), 1, n, file)) {
+      //   std::fclose(file);
+      //   return error_code::file_open_failure;
+      //}
 
-      if (std::fclose(file)) {
-         return error_code::file_close_failure;
-      }
+      //if (std::fclose(file)) {
+      //   return error_code::file_close_failure;
+      //}
 
       return {};
    }
 
    template <class T>
    [[nodiscard]] error_code file_to_buffer(T& buffer, const std::string_view file_name)
    {
-      auto* file = std::fopen(file_name.data(), "rb");
-      return file_to_buffer(buffer, file, file_name);
+      //auto* file = std::fopen(file_name.data(), "rb");
+      return {};//file_to_buffer(buffer, file, file_name);
    }
 
    template <class T>
    std::string file_to_buffer(T&& file_name)
    {
       std::string buffer{};
       file_to_buffer(buffer, std::forward<T>(file_name));
       return buffer;
    }
 
    inline std::filesystem::path relativize_if_not_absolute(const std::filesystem::path& working_directory,
                                                            const std::filesystem::path& filepath)
    {
       if (filepath.is_absolute()) {
          return filepath;
       }
 
       return working_directory / filepath;
    }
 }
 
 #if defined(_MSC_VER) && !defined(__clang__)
 // restore disabled warning
 #pragma warning(pop)
 #endif
